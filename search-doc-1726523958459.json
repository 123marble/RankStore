[{"title":"Util","type":0,"sectionRef":"#","url":"/RankStore/api/Util","content":"On this page Util Show Private","keywords":""},{"title":"RankStore","type":0,"sectionRef":"#","url":"/RankStore/api/RankStore","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#types","content":" "},{"title":"entry​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#entry","content":"&lt;/&gt; type entry = { id: string, rank: number, score: number } An array of strings, a number, or nil.  "},{"title":"setResult​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#setResult","content":"&lt;/&gt; type setResult = { prevRank: number, prevScore: number, newRank: number, newScore: number } An array of strings, a number, or nil. "},{"title":"Functions​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#functions","content":" "},{"title":"GetRankStore​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#GetRankStore","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore.GetRankStore( name: string,-- Name of the RankStore numBuckets: number?,-- The number of buckets to use maxBucketSize: number?,-- Maximum number of entries in each bucket lazySaveTime: number?,-- Time in seconds to wait before saving the data to the DataStore. parallel: boolean?,-- Whether to save the data in parallel dataStructure: dataStructure?,-- The data structure to use. &quot;table&quot;, &quot;string&quot; or &quot;avl&quot;. Default is &quot;table&quot;. compression: compression?-- The compression algorithm to use. &quot;base91&quot; or &quot;none&quot;. Default is &quot;base91&quot;. ) → RankStore Creates or retrieves a Rank Store with the provided name. Default is 60 seconds. -1 disables lazy saving but be advised that this significantly increases the number of DataStore writes. For use cases requiring a mixture of read/write operations, avl is best because insertion into an AVL tree is O(log N). For read only use cases, string is best because only the entries that are read are decompressed. In comparison to the other data structures, these will decompress the entire leaderboard when fetching from the DataStore. Conversely, string is terrible for leaderboard insertions because each insertion copies the entire leaderboard in memory, which is O(N).  "},{"title":"SetScoreAsync​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#SetScoreAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore:SetScoreAsync( id: number,-- The id of the entry. A number to uniquely identify the entry, typically a userId. score: number-- The score to set ) → setResult Sets the score for the given id.  "},{"title":"GetEntryAsync​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#GetEntryAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore:GetEntryAsync( id: number-- The id of the entry. ) → entry Gets the entry for the given id.  "},{"title":"GetTopScoresAsync​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#GetTopScoresAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore:GetTopScoresAsync( n: number-- The number of scores to get ) → {entry} Gets the top n scores.  "},{"title":"UpdateNumBucketsAsync​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#UpdateNumBucketsAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore:UpdateNumBucketsAsync( n: number-- The number of buckets to update to. This should be greater than the current number of buckets. ) → () Increase the number of buckets used. This method can be used once the existing buckets are full to allow for more entries to be added. In order to minimise query time, the existing entires are distributed equally among the new buckets. This operation reads your entire RankStore and writes it into the new buckets. This is a costly operation if you RankStore is large.:::  "},{"title":"FlushBuffer​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#FlushBuffer","content":"&lt;/&gt; RankStore:FlushBuffer() → () Manually flush the buffer to force a write to the DataStore. Use lazySaveTime to automatically flush the buffer at regular intervals.  "},{"title":"ClearAsync​","type":1,"pageTitle":"RankStore","url":"/RankStore/api/RankStore#ClearAsync","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; RankStore:ClearAsync() → () Clears all entries in the RankStore. This actually just increments the keys used in the underlying DataStore so no data is actually deleted. However there is no support to rollback after calling this function at present. "}]