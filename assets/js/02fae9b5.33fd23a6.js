"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[331],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>k});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(r),d=a,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||l;return r?n.createElement(k,o(o({ref:t},p),{},{components:r})):n.createElement(k,o({ref:t},p))}));function k(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},76647:(e,t,r)=>{r.r(t),r.d(t,{contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var n=r(87462),a=(r(67294),r(3905));const l={},o=void 0,i={type:"mdx",permalink:"/RankStore/",source:"@site/pages/index.md",description:"\ud83d\udea7 This library is still under construction...\ud83d\udea7",frontMatter:{}},s=[{value:"Concurrency",id:"concurrency",level:2},{value:"DataStore Limits",id:"datastore-limits",level:2},{value:"Data Limits",id:"data-limits",level:3},{value:"Server and Throughput Limits",id:"server-and-throughput-limits",level:3},{value:"How do I run the unit tests?",id:"how-do-i-run-the-unit-tests",level:2}],u={toc:s},p="wrapper";function c(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"\ud83d\udea7 This library is still under construction...\ud83d\udea7"),(0,a.kt)("h1",{id:"rank-store"},"Rank Store"),(0,a.kt)("p",null,"RankStore is a reliable and scalable system for managing persistent leaderboards using ROBLOX DataStores. RankStore provides a ranking of leaderboard identities based on a score. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\ud83d\udd0d Employs Binary Search for optimal insertion and retrieval of entries"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\ude80 Compresses data to a higher base to minimise storage size"),(0,a.kt)("li",{parentName:"ul"},"\ud83d\udee1\ufe0f Ensures high data integrity by using atomic updates where possible or calling recovery methods in the event of consistency errors"),(0,a.kt)("li",{parentName:"ul"},"\u2b50 Stores data across multiple keys to be scalable to thousands of identities")),(0,a.kt)("p",null,"This module aims to overcome the commonly encountered limitation of the Ordered Datastore which does not allow retrieval of specific ranks. At present, Ordered Datastores can only read 100 records per page and the entries must be read in sequence, which is impractical for large leaderboards with thousands of entries."),(0,a.kt)("h1",{id:"limitations"},"Limitations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Some use cases will be too intensive for this module. While RankStore has been designed with efficiency in mind, it has to operate within the ",(0,a.kt)("a",{parentName:"li",href:"https://create.roblox.com/docs/cloud-services/data-stores#server-limits"},"limits of ROBLOX Datastores"),", which cannot be changed. See the ",(0,a.kt)("a",{parentName:"li",href:"#performance"},"Performance Section")," to gauge whether RankStore is viable for your use case."),(0,a.kt)("li",{parentName:"ul"},"The entry ID and score must be 5 byte and 4 byte ",(0,a.kt)("strong",{parentName:"li"},"integers")," respectively.")),(0,a.kt)("h1",{id:"usage"},"Usage"),(0,a.kt)("p",null,"Add `` to your wally.toml or grab the model here."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local RankStore = require(game.ServerScriptService.RankStore)\nlocal rankStore = RankStore.GetRankStore("MyLeaderboard")\n\nrankStore:SetScoreAsync(1, 25) -- pass in user id, score\nrankStore:SetScoreAsync(2, 50)\nrankStore:SetScoreAsync(3, 20)\nrankStore:SetScoreAsync(4, 75)\n\nprint(rankStore:GetTopScoresAsync(10))\n\nprint(rankStore:GetEntryAsync(3))\n')),(0,a.kt)("p",null,"Full API is available on ",(0,a.kt)("a",{parentName:"p",href:"https://123marble.github.io/RankStore/api/RankStore"},"123marble.github.io/RankStore/api/RankStore"),"."),(0,a.kt)("h1",{id:"performance"},"Performance"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Method"),(0,a.kt)("th",{parentName:"tr",align:null},"Algorithm Time Complexity"),(0,a.kt)("th",{parentName:"tr",align:null},"Network Time Complexity"),(0,a.kt)("th",{parentName:"tr",align:null},"Datastore Requests"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"GetRankStore"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,a.kt)("td",{parentName:"tr",align:null},"1 GetAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"SetScoreAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"O(log n)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,a.kt)("td",{parentName:"tr",align:null},"2 UpdateAsync",(0,a.kt)("br",null)," N-1 GetAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"GetEntryAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"O(log n)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,a.kt)("td",{parentName:"tr",align:null},"N GetAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"GetTopScoresAsync (k)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(k)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(n)"),(0,a.kt)("td",{parentName:"tr",align:null},"N GetAsync")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"RemoveEntryAsync"),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"ClearAsync"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,a.kt)("td",{parentName:"tr",align:null},"O(1)"),(0,a.kt)("td",{parentName:"tr",align:null},"1 SetAsync")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"N=num buckets, n=total entries")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NB: A DataStore GetAsync or UpdateAsync request retrieves the entire value over the network so the actual time complexity for any leaderboard operations is O(n).")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NB: The N GetAsync requests are always made in parallel.")),(0,a.kt)("h2",{id:"concurrency"},"Concurrency"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"How DataStore handles concurrent requests is not documented."),(0,a.kt)("li",{parentName:"ul"},"Number of Datastore keys is effectively the maximum number of maximum concurrent SetScoreAsync requests.")),(0,a.kt)("h2",{id:"datastore-limits"},"DataStore Limits"),(0,a.kt)("h3",{id:"data-limits"},"Data Limits"),(0,a.kt)("p",null,"Each entry requires only 9 characters for storage. The current storage limit for DataStore is 4,194,304 characters per key which means that approximately a maximum of 450k entries are storable in 1 key."),(0,a.kt)("h3",{id:"server-and-throughput-limits"},"Server and Throughput Limits"),(0,a.kt)("p",null,"There is a trade-off between number of keys and the maximum number of records per key. Choosing a higher number of keys will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Worsen the DataStore request budget because the number of GetAsync requests is linearly proportional to the number of keys."),(0,a.kt)("li",{parentName:"ul"},"Improve the DataStore throughput budget because throughput limits are enforced per key.")),(0,a.kt)("p",null,"Conversely, increasing the size of individual keys will improve the request budget but worsen the throughput budget."),(0,a.kt)("h1",{id:"contribute"},"Contribute"),(0,a.kt)("h2",{id:"how-do-i-run-the-unit-tests"},"How do I run the unit tests?"),(0,a.kt)("p",null,"Testing requires Wally, Rojo, and Roblox Studio."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Install packages with ",(0,a.kt)("inlineCode",{parentName:"li"},"wally install")),(0,a.kt)("li",{parentName:"ol"},"Sync ",(0,a.kt)("inlineCode",{parentName:"li"},"rojo")," with ",(0,a.kt)("inlineCode",{parentName:"li"},"default.project.json")),(0,a.kt)("li",{parentName:"ol"},"Run the Roblox Studio place"),(0,a.kt)("li",{parentName:"ol"},"Check output window for test status")))}c.isMDXComponent=!0}}]);